#include "BaseLib.h"
#include "TaskTools.h"


CToolsBaseLibrary::CToolsBaseLibrary(
	char* szAppName,
	char* szLogPath,
	char* szTempPath,
	int nTaskPoolThreadMax,
	bool bDebug2TTYFlag,
	_BASE_LIBRARY_PRINT_INFO_CALLBACK pPrintInfoCallback,
	void* pPrintInfoCallbackParam,
	_APP_INFO_OUT_CALLBACK pInfoOutCallback,
	void* pInfoOutCallbackParam)
{
	m_pDebug = null; //各指针变量赋初值null
	m_pTaskPool = null; //这是预防某个初始化动作失败后
	m_pMemPool = null; //跳转，导致后续指针没有赋值
	m_pLog = null; //成为“野指针”
				   //保存各个路径字符串的值
	SafeStrcpy(m_szAppName, szAppName, TOOLS_APPLICATION_NAME_SIZE);
	SafeStrcpy(m_szLogPathName, szLogPath, TOOLS_APP_LOG_PATH_NAME_SIZE);
	SafeStrcpy(m_szTempPathName, szTempPath, TOOLS_APP_TEMP_PATH_NAME_SIZE);
	//保存信息打印回调函数相关指针
	m_pPrintInfoCallback = pPrintInfoCallback;
	m_pPrintInfoCallbackParam = pPrintInfoCallbackParam;
	//初始化随机数种子
	srand((unsigned int)time(NULL));
#ifdef WIN32
	{ //注意，大括号限定作用域，可以临时定义变量
		m_bSocketInitFlag = false;
		WORD wVersionRequested;
		int err;
		wVersionRequested = MAKEWORD(2, 2);
		err = WSAStartup(wVersionRequested, &m_wsaData);
		if (err != 0)
		{
			TOOLS_DEBUG("Socket init fail!\n");
		}
		else m_bSocketInitFlag = true;
	}
#else // Non-Windows
#endif

	//初始化Debug对象
	m_pDebug = new CToolsLowDebug(m_szLogPathName,
		m_szAppName,
		bDebug2TTYFlag,
		pInfoOutCallback,
		pInfoOutCallbackParam);
	if (!m_pDebug) return;
	//开始第一步信息输出，Hello World，这是笔者习惯，每个程序一启动，打印这个信息
	TOOLS_DEBUG("------------------------------------------\n");
	//TOOLS_DEBUG("Hello World!\n");

	//初始化内存池
	m_pMemPool = new CToolsMemoryPoolWithLock(m_pDebug);
	if (!m_pMemPool)
	{ //如果失败，这里已经能打印Debug 信息了
		TOOLS_DEBUG("CToolsBaseLibrary(): m_pMemPool new fail!\n");
		return;
	}

	//初始化日志系统
	m_pLog = new CToolsLog(m_pDebug, m_pMemPool,
		m_szLogPathName, //注意，这里使用日志路径
		m_szAppName);
	if (m_pLog)
	{ //注意，此时已经可以利用内存池的注册机制
		m_pMemPool->Register(m_pLog, "CToolsBaseLibrary::m_pLog");
	}

	//初始化任务池及执行体
	m_pTaskPool = new CToolsTaskPool(this, nTaskPoolThreadMax);
	if (m_pTaskPool)
	{ //注意，此时已经可以利用内存池的注册机制
		m_pMemPool->Register(m_pTaskPool, "CToolsBaseLibrary::m_pTaskPool");
	}	
	m_pTaskRun = new CToolsTaskRun(this);
	if (m_pTaskRun)
	{ //注意，此时已经可以利用内存池的注册机制
		m_pMemPool->Register(m_pTaskRun, "CToolsBaseLibrary::m_pTaskRun");
	}

	TimeSetNow(m_tLastPrint); //计时因子
	 //注意，任务回调函数的参数是本对象指针
	if (!m_pTaskRun->StartTask(InfoPrintTaskCallback, this))
	{ //失败则报警
		m_pLog->_XGSyslog("CToolsBaseLibrary:: start print info task fail!\n");
	} 
	//聚合工具类启动完毕标志，也是应用程序逻辑开始启动标志
	TOOLS_DEBUG(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n");
}

CToolsBaseLibrary::~CToolsBaseLibrary()
{ //笔者习惯，这是应用程序逻辑开始退出的标志，相对于构造函数中的输出
	TOOLS_DEBUG("<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n");
	//这是一个技巧，退出时，笔者喜欢按照功能模块的划分，打印一些数字
	//当某个模块线程出现bug，其退出逻辑很可能受到影响，导致退出时挂死
	//此时只要简单观察数字打到几，就可以轻松判定是下面哪一步出现了问题，方便debug
	TOOLS_PRINTF("1\n");
	//设置内存池的关闭标志，内存块的Free 动作将直接释放，不再推入内存栈，加快程序运行
	m_pMemPool->SetCloseFlag();
	TOOLS_PRINTF("2\n");
	TOOLS_PRINTF("3\n");
	if (m_pTaskRun) //退出线程池运行体，注意其中反注册动作
	{
		m_pMemPool->UnRegister(m_pTaskRun);
		delete m_pTaskRun;
		m_pTaskRun = null;
	} 
	TOOLS_PRINTF("4\n");
	TOOLS_PRINTF("5\n");
	if (m_pTaskPool) //退出线程池，注意其中反注册动作
	{
		m_pMemPool->UnRegister(m_pTaskPool);
		delete m_pTaskPool;
		m_pTaskPool = null;
	}
	TOOLS_PRINTF("6\n");
	if (m_pLog) //退出Log 日志模块，注意其中反注册动作
	{
		m_pMemPool->UnRegister(m_pLog);
		delete m_pLog;
		m_pLog = null;
	}
	TOOLS_PRINTF("7\n");
	if (m_pMemPool) //退出内存池
	{
		delete m_pMemPool;
		m_pMemPool = null;
	}
	TOOLS_PRINTF("8\n");
	//TOOLS_DEBUG("Bye World!\n"); //笔者习惯，“再见，世界”
	TOOLS_DEBUG("------------------------------------------\n");
	if (m_pDebug) //退出Debug 对象
	{
		delete m_pDebug;
		m_pDebug = null;
	} 
	TOOLS_PRINTF("9\n");
#ifdef WIN32
	if (m_bSocketInitFlag)
	{
		if (LOBYTE(m_wsaData.wVersion) != 2 ||
			HIBYTE(m_wsaData.wVersion) != 2)
		{
			WSACleanup();
		} 
		m_bSocketInitFlag = false;
	}
#else // Non-Windows
#endif
}

bool CToolsBaseLibrary::InfoPrintTaskCallback(void* pCallParam, int& nStatus)
{ //强制指针类型转换，获得本对象指针
	CToolsBaseLibrary* pThis = (CToolsBaseLibrary*)pCallParam;
	//检测是否已经等到2 秒，否则返回
	if (TimeIsUp(pThis->m_tLastPrint, MAIN_LOOP_DELAY))
	{
		TimeSetNow(pThis->m_tLastPrint); //更新当前时间
		TOOLS_PRINTF("*******************************************\n");
		pThis->m_pTaskPool->PrintInfo(); //打印任务池信息
		pThis->m_pTaskRun->PrintInfo(); //打印任务池运行体信息
		pThis->m_pMemPool->PrintInfo(); //打印内存池信息
		if (pThis->m_pPrintInfoCallback) //回调应用层打印函数
			pThis->m_pPrintInfoCallback(pThis->m_pPrintInfoCallbackParam);
		TOOLS_PRINTF("*******************************************\n");
		TOOLS_PRINTF("\n");
	} 
	return true; //返回真，永远循环
}












